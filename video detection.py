# -*- coding: utf-8 -*-
"""video dataaug.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x5Y6gfRRq6Yj-HPwI7u4rMoVARaCehvv
"""

import os
import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, TimeDistributed, LSTM, Flatten, Dense
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Function to extract frames from video
def extract_frames(video_path, num_frames):
    frames = []
    cap = cv2.VideoCapture(video_path)

    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    # Determine frame indices to extract
    indices = np.linspace(0, total_frames - 1, num_frames, dtype=int)

    for i in indices:
        cap.set(cv2.CAP_PROP_POS_FRAMES, i)
        ret, frame = cap.read()

        if not ret:
            print(f"Error reading frame {i} from {video_path}")
            continue

        frame = cv2.resize(frame, (224, 224))  # Resize frame if necessary
        frames.append(frame)

    cap.release()

    return frames

# Function to load data
def load_data(folder_path, num_videos, prefix, frames_per_video):
    data = []
    for i in range(1, num_videos + 1):
        video_name = f"{prefix} ({i}).mp4"
        video_path = os.path.join(folder_path, video_name)

        # Check if video file exists
        if not os.path.exists(video_path):
            print(f"Video file not found: {video_path}")
            continue

        # Extract frames from video
        frames = extract_frames(video_path, frames_per_video)

        # Append frames to data list
        if frames:
            data.append(frames)

    return np.array(data)

# Data Augmentation using ImageDataGenerator
datagen = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Paths to your real and fake video directories
real_data_path = '/content/drive/MyDrive/Celeb-DF dataset/real'
fake_data_path = '/content/drive/MyDrive/Celeb-DF dataset/fake'

# Number of frames to extract per video
frames_per_video = 30

# Load data
real_data = load_data(real_data_path, 75, 'real', frames_per_video)  # Load 75 real videos
fake_data = load_data(fake_data_path, 75, 'fake', frames_per_video)  # Load 75 fake videos

# Combine real and fake data
X = np.vstack((real_data, fake_data))

# Ensure that the number of labels matches the number of samples in X
num_real_samples = real_data.shape[0]
num_fake_samples = fake_data.shape[0]
y = np.vstack((np.zeros((num_real_samples, 1)), np.ones((num_fake_samples, 1))))

# Shuffle data
indices = np.arange(X.shape[0])
np.random.shuffle(indices)
X = X[indices]
y = y[indices]

# Apply Data Augmentation
augmented_data = []
for videos in X:
    augmented_videos = []
    for frames in videos:
        # Convert list of frames to numpy array and reshape to 4D tensor
        frames_reshaped = np.array(frames).reshape(-1, 224, 224, 3)

        # Apply data augmentation
        augmented_frames = [datagen.random_transform(frame) for frame in frames_reshaped]

        # Convert augmented frames back to list and reshape to original shape
        augmented_frames = [frame.reshape(224, 224, 3) for frame in augmented_frames]

        augmented_videos.append(augmented_frames)
    augmented_data.append(augmented_videos)

X_augmented = np.array(augmented_data)

# Reshape data
X_augmented = X_augmented.reshape(-1, frames_per_video, 224, 224, 3)

# Define model
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False

input_layer = Input(shape=(frames_per_video, 224, 224, 3))
feature_extractor = TimeDistributed(base_model)(input_layer)
flatten_layer = TimeDistributed(Flatten())(feature_extractor)
lstm_layer = LSTM(128, return_sequences=False)(flatten_layer)  # Set return_sequences to False
output_layer = Dense(1, activation='sigmoid')(lstm_layer)

model = Model(inputs=input_layer, outputs=output_layer)

# Compile model
optimizer = Adam(lr=1e-4)
model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

# Train model
model.fit(X_augmented, y, batch_size=16, epochs=10, validation_split=0.2)

# Save model
model.save('/content/drive/MyDrive/Celeb-DF dataset/video_detection_model3.h5')
print("Model saved successfully!")

from tensorflow.keras.models import load_model

model = load_model('/content/drive/MyDrive/Celeb-DF dataset/video_detection_model3.h5')

import cv2

def extract_frames_from_video(video_path, num_frames):
    frames = []
    cap = cv2.VideoCapture(video_path)

    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    indices = np.linspace(0, total_frames - 1, num_frames, dtype=int)

    for i in indices:
        cap.set(cv2.CAP_PROP_POS_FRAMES, i)
        ret, frame = cap.read()

        if not ret:
            print(f"Error reading frame {i} from {video_path}")
            continue

        frame = cv2.resize(frame, (224, 224))
        frames.append(frame)

    cap.release()

    return np.array(frames)

def preprocess_frames(frames):
    frames = frames.astype('float32') / 255.0
    return frames

def predict_on_video(video_path, num_frames):
    frames = extract_frames_from_video(video_path, num_frames)
    frames = preprocess_frames(frames)

    # Reshape frames to (1, num_frames, 224, 224, 3)
    frames = frames.reshape((1, num_frames, 224, 224, 3))
    # Perform prediction
    global prediction_score
    prediction_score = model.predict(frames)[0][0]

    # Set threshold for binary prediction
    threshold = 0.5

    if prediction_score > threshold:
        return "Real"
    else:
        return "Fake"

import numpy as np

video_path = '/content/drive/MyDrive/Celeb-DF dataset/fake/fake (103).mp4'
num_frames = 30  # Number of frames to extract from the video

prediction_result = predict_on_video(video_path, num_frames)
print(prediction_score)
print(f"Prediction: {prediction_result}")

from google.colab import drive
drive.mount(/content/drive)

